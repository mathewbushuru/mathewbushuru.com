---
title: "Data Structures and Algorithms"
publishedAt: "2024-08-18"
lastModified: "2024-08-18"
published: "yes"
featured: "yes"
summary: "Computer science algorithms and data structures implemented in Java, C++,JavaScript, C, TypeScript and Python."
preview: "This article contains in-depth explanations to key computer science concepts, algorithms and data structures. They are implemented in `JavaScript`, `Java`, `C++`, `Python`, `TypeScript`, `C` and `C#`. This repository is intended to be my online reference / notes as I learn these topics and I hope you find this information valuable."
---

This article contains in-depth explanations to key computer science concepts, algorithms and data structures. They are implemented in `JavaScript`, `Java`, `C++`, `Python`, `TypeScript`, `C` and `C#`. This repository is intended to be my online reference / notes as I learn these topics and I hope you find this information valuable.

{/* ## Table of Contents

- [Concepts](#concepts)
  - [Big O](#big-o)
- [Algorithms](#algorithms)
  - [Sorting Algorithms](#sorting-algorithms)
    - [Insertion Sort](#insertion-sort)
  - [Search Algorithms](#search-algorithms)
    - [Binary Search](#binary-search)
- [Data Structures](#data-structures)

  - [Arrays and Strings](#arrays-and-strings)
  - [Trees](#trees)
    - [Binary Trees](#binary-trees)
    - [Binary Search Trees](#binary-search-trees) */}

## General Concepts

### Big O

Big O notation describes the upper bound of an algorithm in the worst case scenario, meaning how the runtime or space requirements grow as the input size grows. It gives us an idea on the efficiency of an algorithm, particularly in the context of scalability.

Below are some common Big-O complexities, from fastest to slowest:

- **O(1), constant time**: Algorithm takes constant amount of time, regardless of input size.
- **O(log(n)), logarithmic time**: Common in algorithms that decrease the input size with each iteration, e.g binary search.
- **O(n)), linear time**: Runtime grows linearly with input size, e.g simple search algorithms
- **O(nlog(n))), loglinear time**: The running time increases linearly with input size, but it incorporates a logarithmic growth factor e.g merge sort
- **O(n^2), O(n^3), polynomial time**: Often seen in nested loops e.g bubble sort
- **O(2^n), exponential time**: The running time doubles for each additional element in the input. It is typically in recursive processes where each step generates multiple additional recursive steps e.g the recursive implementation of Fibonacci numbers.
- **O(n!), factorial time**: Very slow algorithms typically in problems requiring permutations or combinations, eg solving the traveling salesman problem by brute force.

Big O is also used to represent how the amount of memory used by an algorithm grows with input size. We ignore the constant coeffiecients and smaller terms in Big O.

**O(1) Constant time example - accessing element from array**

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent
    value="js"
>
```js
function getArrayElement(arr, index) {
  return arr[index];
}

const arr1 = [1, 2, 3, 4, 5];
// 3
console.log(getArrayElement(arr1, 2));
```
</TabsContent>
<TabsContent
    value="java"
>
```java 
public class ConstantTimeExample {
    public static void main(String[] args){
        int[] arr1 = {1, 2, 3, 4, 5};
        // 3
        System.out.println(getArrayElement(arr1, 2));
    }

    public static int getArrayElement(int[] arr, int index){
        return arr[index];
    }
}
```
</TabsContent>
<TabsContent
    value="cpp"
>
```cpp
// g++ constantTimeExample.cpp -o constantTimeExample -std=c++20 && ./constantTimeExample

#include <iostream>
#include <array>

template <size_t N>
int getArrayElement(const std::array<int, N>& arr, size_t index);

int main()
{
    std::array<int, 5> arr1 = { 1, 2, 3, 4, 5 };

    // 3
    std::cout << getArrayElement(arr1, 2) << std::endl;

    return 0;
}

template <size_t N>
int getArrayElement(const std::array<int, N>& arr, size_t index)
{
    return arr[index];
}
```
</TabsContent>
</Tabs>

**O(log(n)) logarithmic time example - fast power algorithm**

Fast power algorithm calculates the power of a number in logarithmic time using the 'exponentiation by squaring' method.

If we want to compute a^n:

- if n is even, then a^n = (a^(n/2))^2
- if n is odd, then a^n = a x a^(n-1)

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent
    value="js"
>
```js
function fastPower(base, exponent) {
  if (exponent === 0) {
    return 1;
  }

  const halfPower = fastPower(base, Math.floor(exponent / 2));

  if (exponent % 2 === 0) {
    return halfPower * halfPower;
  } else {
    return base * halfPower * halfPower;
  }
}

// 1024
console.log(fastPower(2, 10));
```
</TabsContent>
<TabsContent
    value="java"
>
```java 
public class FastPowerExample {
    public static void main(String[] args) {
        // 1024
        System.out.println(fastPower(2, 10));
    }

    public static long fastPower(long base, int exponent){
        if (exponent == 0) return 1; 

        long halfPower = fastPower(base, exponent / 2); 

        if (exponent % 2 == 0){
            return halfPower * halfPower;
        } else {
            return base * halfPower * halfPower;
        }
    }
}
```
</TabsContent>
<TabsContent
    value="cpp"
>
```cpp 
// g++ fastPower.cpp -o fastPower -std=c++20 && ./fastPower

#include <iostream>

long long fastPower(long long base, long long exponent);

int main()
{
    // 1024
    std::cout << fastPower(2, 10) << std::endl;
}

long long fastPower(long long base, long long exponent)
{
    if (exponent == 0)
    {
        return 1;
    }

    long long halfPower = fastPower(base, exponent / 2);

    if (exponent % 2 == 0)
    {
        return halfPower * halfPower;
    }
    else
    {
        return base * halfPower * halfPower;
    }
}
```
</TabsContent>
</Tabs>

**O(n) Linear time example - max element in unsorted list**

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent
    value="js"
>
```js
function findMax(arr) {
  let maxVal = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > maxVal) {
      maxVal = arr[i];
    }
  }

  return maxVal;
}

const sampleArray = [3, 1, 4, 5, 9, 2, 6, 5];
// 9
console.log(findMax(sampleArray));
```
</TabsContent>
<TabsContent value="java">
```java 
public class LinearTimeExample {
    public static void main(String[] args){
        int[] sampleArray = {3, 1, 4, 5, 9, 2, 6, 5};
        // 9
        System.out.println(findMax(sampleArray));
    }

    public static int findMax(int[] arr){
        int maxVal = arr[0];

        for (int i = 1; i < arr.length; i++){
            if (arr[i] > maxVal){
                maxVal = arr[i];
            }
        }

        return maxVal;
    }
}
```
</TabsContent>
<TabsContent value="cpp">
```cpp 
// g++ linearTimeExample.cpp -o linearTimeExample -std=c++20 && ./linearTimeExample

#include <iostream>
#include <vector>

int findMax(const std::vector<int>& vec);

int main()
{
    std::vector<int> sampleVector{ 3, 1, 4, 5, 9, 2, 6, 5 };

    // 9
    std::cout << findMax(sampleVector) << std::endl;

    return 0;
}

int findMax(const std::vector<int>& vec)
{
    int maxVal{ vec[0] };

    for (size_t i{ 0 }; i < vec.size(); ++i)
    {
        if (vec[i] > maxVal)
        {
            maxVal = vec[i];
        }
    }

    return maxVal;
}
```
</TabsContent>
</Tabs>

**O(nlog(n)) LogLinear time example - merge sort**

For each increase in input size, the time it takes to complete the task grows in a way that's proportional to both the size of the input and the logarithm of that size. The logarithmic component typically comes from dividing the problem into smaller parts (divide and conquer), and the linear component is from processing each part.

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent value="js">
```js
function mergeSort(arr) {
  // base case
  if (arr.length < 2) {
    return arr;
  }

  // divide array into two
  const leftArr = arr.slice(0, arr.length / 2);
  const rightArr = arr.slice(arr.length / 2);

  // sort each half array
  const sortedLeft = mergeSort(leftArr);
  const sortedRight = mergeSort(rightArr);

  // merge sorted left and right arrays
  const sortedArr = mergeSortedArrays(sortedLeft, sortedRight);

  return sortedArr;
}

function mergeSortedArrays(arr1, arr2) {
  let i = 0;
  let j = 0;
  const sortedArr = [];

  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] < arr2[j]) {
      sortedArr.push(arr1[i]);
      i += 1;
    } else {
      sortedArr.push(arr2[j]);
      j += 1;
    }
  }

  while (i < arr1.length) {
    sortedArr.push(arr1[i]);
    i += 1;
  }

  while (j < arr2.length) {
    sortedArr.push(arr2[j]);
    j += 1;
  }

  return sortedArr;
}

const arr = [2, 4, 9, 6, 1, 8, 3, 5, 7];
// [ 1, 2, 3, 4, 5, 6, 7, 8, 9]
console.log(mergeSort(arr));
```
</TabsContent>
<TabsContent value="java">
```java 
import java.util.List;
import java.util.ArrayList;

public class MergeSort {
    public static List<Integer> mergeSort(List<Integer> list) {
        // base case - already sorted
        if (list.size() < 2) {
            return list;
        }

        // otherwise divide list into two halves
        List<Integer> leftList = new ArrayList<>(list.subList(0, list.size() / 2));
        List<Integer> rightList = new ArrayList<>(list.subList(list.size() / 2, list.size()));

        // sort each half
        List<Integer> sortedLeft = mergeSort(leftList);
        List<Integer> sortedRight = mergeSort(rightList);

        // merge sorted halves
        return merge(sortedLeft, sortedRight);
    }

    private static List<Integer> merge(List<Integer> left, List<Integer> right) {
        List<Integer> merged = new ArrayList<>();

        int leftIndex = 0;
        int rightIndex = 0;

        // merge the two arrays while they each have elements
        while (leftIndex < left.size() && rightIndex < right.size()) {
            if (left.get(leftIndex) < right.get(rightIndex)) {
                merged.add(left.get(leftIndex));
                leftIndex += 1;
            } else {
                merged.add(right.get(rightIndex));
                rightIndex += 1;
            }
        }

        // append any remaining elements
        while (leftIndex < left.size()){
            merged.add(left.get(leftIndex));
            leftIndex += 1;
        }

        while (rightIndex < right.size()){
            merged.add(right.get(rightIndex));
            rightIndex += 1;
        }

        return merged;
    }

    public static void main(String[] args) {
        List<Integer> arr = List.of(2, 4, 9, 6, 1, 8, 3, 5, 7);
        List<Integer> sortedArr = mergeSort(arr);
        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
        System.out.println(sortedArr);
    }
}
```
</TabsContent>
<TabsContent value="cpp">
```cpp 
// g++-13 mergeSort.cpp -o mergeSort -std=c++20 && ./mergeSort

#include <iostream>
#include <vector>

std::vector<int> mergeSort(const std::vector<int>& vec);
std::vector<int> merge(const std::vector<int>& left, const std::vector<int>& right);

int main()
{
    std::vector<int> sampleVector{ 2, 4, 9, 6, 1, 8, 3, 5, 7 };

    auto sortedVector = mergeSort(sampleVector);

    // 1 2 3 4 5 6 7 8 9
    for (int value : sortedVector)
    {
        std::cout << value << " ";
    }
    std::cout << std::endl;

    return 0;
}

std::vector<int> mergeSort(const std::vector<int>& vec)
{
    if (vec.size() < 2)
    {
        return vec;
    }

    int mid = vec.size() / 2;

    // call vector constructor with iterators from original vector
    std::vector<int> leftHalf(vec.begin(), vec.begin() + mid);
    std::vector<int> rightHalf(vec.begin() + mid, vec.end());

    std::vector<int> sortedLeft = mergeSort(leftHalf);
    std::vector<int> sortedRight = mergeSort(rightHalf);

    return merge(sortedLeft, sortedRight);
}

std::vector<int> merge(const std::vector<int>& left, const std::vector<int>& right)
{
    std::vector<int> result;

    auto leftIt = left.begin();
    auto rightIt = right.begin();

    while (leftIt < left.end() && rightIt < right.end())
    {
        if (*leftIt < *rightIt)
        {
            result.push_back(*leftIt);
            ++leftIt;
        }
        else
        {
            result.push_back(*rightIt);
            ++rightIt;
        }
    }

    // result.insert(result.end(), leftIt, left.end());
    // result.insert(result.end(), rightIt, right.end());

    while (leftIt < left.end())
    {
        result.push_back(*leftIt);
        ++leftIt;
    }

    while (rightIt < right.end())
    {
        result.push_back(*rightIt);
        ++rightIt;
    }

    return result;
}
```
</TabsContent>
</Tabs>

**O(n^3) Polynomial time example - 3 Sum problem naive solution**

For the three sum problem, we are given an array of n numbers, and we determine if there exists three elements a, b and c in the array such that a + b + c = 0;


```js
// JavaScript
function threeSumZero(arr) {
  let n = arr.length;

  for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
      for (let k = j + 1; k < n; k++) {
        if (arr[i] + arr[j] + arr[k] === 0) {
          return [arr[i], arr[j], arr[k]];
        }
      }
    }
  }

  return null;
}

const sampleArray = [-1, 0, 1, 2, -1, -4];
// [-1, 0, 1]
console.log(threeSumZero(sampleArray));
```

Note that we can get more efficient implementations to the three sum example. In the example below, we use the two-pointer technique to reduce the runtime to O(n^2). The idea is to sort the array first, and then for each element, use two pointers to find the pair that sums up to negate that element.

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent value="js">
```js
function threeSumZeroBetter(arr) {
  // eg arr = [-1, 0, 1, 2, -1, -4]

  // sort the array, O(nlogn)
  // arr now [-4, -1, -1, 0, 1, 2]
  arr.sort((a, b) => a - b);

  for (let i = 0; i < arr.length - 2; i++) {
    if (i > 0 && arr[i] === arr[i - 1]) {
      // skip duplicates
      continue;
    }

    let left = i + 1;
    let right = arr.length - 1;

    while (left < right) {
      const sum = arr[i] + arr[left] + arr[right];

      if (sum === 0) {
        return [arr[i], arr[left], arr[right]];
      } else if (sum < 0) {
        left++;
      } else {
        right--;
      }
    }
  }

  // no triplet found
  return null;
}

// [ -1, -1, 2 ]
console.log(threeSumZeroBetter(sampleArray));
```
</TabsContent >
<TabsContent value="java">
```java 
import java.util.Arrays;

public class ThreeSum {
    public static int[] threeSumZero(int[] arr) {
        int n = arr.length;

        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; j < n; j++) {
                    if (arr[i] + arr[j] + arr[k] == 0) {
                        int[] result = { arr[i], arr[j], arr[k] };
                        return result;
                    }
                }
            }
        }

        return null;
    }

    public static int[] threeSumZeroBetter(int[] arr) {
        Arrays.sort(arr);

        for (int i = 0; i < arr.length - 2; i++) {
            if (i > 0 && arr[i] == arr[i - 1]) {
                continue;
            }

            int left = i + 1;
            int right = arr.length - 1;

            while (left < right) {
                int sum = arr[i] + arr[left] + arr[right];

                if (sum == 0) {
                    int[] result = { arr[i], arr[left], arr[right] };
                    return result;
                } else if (sum < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }

        return null;
    }

    public static void main(String[] args) {
        int[] sampleArr1 = { -1, 0, 1, 2, -1, -4 };
        // [-1, 0, 1]
        System.out.println(Arrays.toString(threeSumZero(sampleArr1)));

        int[] sampleArr2 = { -1, 0, 1, 2, -1, -4 };
        // [-1, -1, 2]
        System.out.println(Arrays.toString(threeSumZeroBetter(sampleArr2)));
    }
}
```
</TabsContent>
<TabsContent value="cpp">
```cpp
// g++ threeSum.cpp -o threeSum -std=c++20 && ./threeSum

#include <iostream>
#include <vector>
#include <algorithm>
#include <stdexcept>

std::vector<int> threeSumZero(const std::vector<int>& vec);
std::vector<int> threeSumZeroBetter(std::vector<int> vec);

int main()
{
    std::vector<int> sampleVector1{ -1, 0, 1, 2, -1, -4 };
    std::vector<int> result1 = threeSumZero(sampleVector1);

    if (result1.empty())
    {
        std::cout << "No triplet found" << std::endl;
    }
    else
    {
        // -1, 0, 1
        std::cout << result1[0] << ", " << result1[1] << ", " << result1[2] << std::endl;
    }

    // using copy constructor
    std::vector<int> sampleVector2(sampleVector1);
    std::vector<int> result2 = threeSumZeroBetter(sampleVector2);

    if (result2.empty())
    {
        std::cout << "No triplet found" << std::endl;
    }
    else
    {
        // -1, -1, 2
        std::cout << result2[0] << ", " << result2[1] << ", " << result2[2] << std::endl;
    }

    return 0;
}

std::vector<int> threeSumZero(const std::vector<int>& vec)
{
    size_t n{ vec.size() };

    if (n < 3)
    {
        throw std::invalid_argument("Input vector must have at least three elements.");
    }

    std::vector<int> result{};
    size_t i, j, k;

    for (i = 0; i < n - 2; ++i)
    {
        for (j = i + 1; j < n - 1; ++j)
        {
            for (k = j + 1; k < n; ++k)
            {
                if (vec.at(i) + vec.at(j) + vec.at(k) == 0)
                {
                    result.insert(result.end(), { vec.at(i), vec.at(j), vec.at(k) });
                    return result;
                }
            }
        }
    }

    return result;
}

std::vector<int> threeSumZeroBetter(std::vector<int> vec)
{
    if (vec.size() < 3)
    {
        throw std::invalid_argument("Input vector must have at least three elements.");
    }

    // modifying vector - that's why i'm not passing it by  reference
    std::sort(vec.begin(), vec.end());

    std::vector<int> result{};
    size_t i, left, right;
    int sum;

    for (i = 0; i < vec.size() - 2; ++i)
    {
        if (i > 0 && vec[i] == vec[i - 1])
        {
            continue;
        }

        left = i + 1;
        right = vec.size() - 1;

        while (left < right)
        {
            sum = vec[i] + vec[left] + vec[right];

            if (sum == 0)
            {
                result.insert(result.end(), { vec[i], vec[left], vec[right] });
                return result;
            }
            else if (sum < 0)
            {
                ++left;
            }
            else
            {
                --right;
            }
        }
    }

    return result;
}
```
</TabsContent>
</Tabs>

**O(2^n) Exponential time example - compute n^th Fibonacci number**

They arise when we have multiple recursion calls for each step of the algorithm.

```js
// JavaScript
function fibonacci(n) {
  if (n <= 1) {
    return n;
  }

  return fibonacci(n - 1) + fibonacci(n - 2);
}

// 55
console.log(fibonacci(10));
```

Note that this native recursive implementation is very inefficient especially for large values of n. We can use memoization to greatly reduce the time complexity by storing previously computed results and avoiding redundant calculations. The optimization below reduces the runtime to O(n).

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
</TabsList>
<TabsContent value="js">
```js
function fibonacciBetter(n, memo = []) {
  if (memo[n] !== undefined) return memo[n];

  if (n <= 1) return n;

  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}

// 55
console.log(fibonacciBetter(10));
```
</TabsContent>
<TabsContent value="java">
```java 
import java.util.Arrays;

public class ExponentialTimeExample {
    public static void main(String[] args) {
        // 55
        System.out.println(fibonacci(10));

        // 55
        System.out.println(fibonacciBetter(10));
    }

    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    // optimized version
    public static int fibonacciBetter(int n) {
        // n + 1 elements: 0 upto and including n
        int[] memo = new int[n + 1];

        Arrays.fill(memo, -1);

        return fibonacciMemo(n, memo);
    }

    private static int fibonacciMemo(int n, int[] memo) {
        if (memo[n] != -1) {
            return memo[n];
        }

        if (n <= 1) {
            return n;
        }

        memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);

        return memo[n];
    }
}
```
</TabsContent>
<TabsContent value="cpp">
```cpp 
// g++ exponentialTimeExample.cpp -o exponentialTimeExample -std=c++20 && ./exponentialTimeExample

#include <iostream>
#include <vector>
#include <stdexcept>

int fibonacci(int n);
int fibonacciBetter(int n, std::vector<int>& memo);

int main()
{
    int n = 10;

    // vector constructor to initialize vector of size n+1 initially with -1s
    std::vector<int> memo(n + 1, -1);

    // 55
    std::cout << fibonacci(n) << std::endl;

    // 55
    std::cout << fibonacciBetter(n, memo) << std::endl;

    return 0;
}

int fibonacci(int n)
{
    if (n < 0)
    {
        throw std::invalid_argument("n should be greater than 0");
    }

    if (n == 0 || n == 1)
    {
        return n;
    }

    return fibonacci(n - 1) + fibonacci(n - 2);
}

int fibonacciBetter(int n, std::vector<int>& memo)
{
    if (n < 0)
    {
        throw std::invalid_argument("n should be greater than 0");
    }

    if (memo[n] != -1)
    {
        return memo[n];
    }

    if (n == 0 || n == 1)
    {
        return n;
    }

    memo[n] = fibonacciBetter(n - 1, memo) + fibonacciBetter(n - 2, memo);
    return memo[n];
}
```
</TabsContent>
</Tabs>

A way to generalize the runtimes of recursive functions is often O(branches^depth), where branches is the number of times each recursive call branches e.g 2 for fibonacci.

{/* **O(n!) Factorial time example - Travelling Salesman Problem**

The  "Travelling Salesman Problem"(TSP) can be naively(brute-force) solved using a factorial-time complexity algorithm. TSP is stated as: Given a list of cities and distances between each pair of cities, find the shortest possible route that visits each city once and returns to the origin city.

The brute-force approach is to generate all possible permutations of cities and calculate the total distance for each permutation. */}

---

## Algorithms

### Sorting algorithms

#### Insertion Sort

Insertion sort builds the final sorted array, one element at a time by shifting elements to the right until the correct position in the sorted portion of the array is found. An intuitive way that I have seen it being described is it is like sorting a hand of playing cards - take a card, find its correct place within sorted cards, and insert it at that location.

***Algorithm***

Initialization

- Assuming we have an unsorted array of numbers: `[9,3,5,1,7,2,8,4]`
- We take the first element and consider it as the sorted portion of the array. `[9]`

Iteration

- Iterate over the remaining elements in the array starting from the second element `i=1`
- In each iteration, compare the current element with the sorted portion of the array, moving elements to the right until we find the correct position to insert the current element `array[i]`

Insertion

- For our example, consider the first element outside the sorted portion, `array[i]=3`
- Compare `3` with the elements in the sorted portion `[9]`
- `3` is smaller than `9` so move `9` one position to the right resulting in `[3,9]` as the current sorted portion of the array

Repeat until the array is sorted

- continue for all the remaining unsorted elements, comparing and shifting as necessary
- Once we reach the end of the array, it will be fully sorted

***Implementation***

<Tabs defaultValue="js">
<TabsList>
    <TabsTrigger value="js">JavaScript</TabsTrigger>
    <TabsTrigger value="java">Java</TabsTrigger>
    <TabsTrigger value="cpp">C++</TabsTrigger>
    <TabsTrigger value="python">Python</TabsTrigger>
    <TabsTrigger value="c">C</TabsTrigger>
    <TabsTrigger value="ts">TypeScript</TabsTrigger>
</TabsList>
<TabsContent value="js">
```js
function insertionSort(array) {
  for (let i = 1; i < array.length; i++) {
    const currVal = array[i];

    let j = i - 1;
    while (j >= 0 && array[j] > currVal) {
      array[j + 1] = array[j];
      j -= 1;
    }

    array[j + 1] = currVal;
  }
  return array;
}

const arr = [9, 3, 5, 1, 7, 2, 8, 4];

// [ 1, 2, 3, 4, 5, 7, 8, 9]
console.log(insertionSort(arr));
```
</TabsContent>
<TabsContent value="java">
```java 
public class insertionSort {
    public static void main(String[] args) {
        int[] arr = { 9, 3, 5, 1, 7, 2, 8, 4 };
        sort(arr);
        // 1 2 3 4 5 6 7 8 9
        printArray(arr);
    }

    public static void sort(int[] array) {
        for (int i = 1; i < array.length; i++) {
            int currVal = array[i];
            int j = i - 1;
            while (j >= 0 && array[j] > currVal) {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = currVal;
        }
    }

    public static void printArray(int[] array) {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```
</TabsContent>
<TabsContent value="cpp">
```cpp 
// g++ insertionSort.cpp -o insertionSort -std=c++20 && ./insertionSort

#include <iostream>
#include <vector>

void insertionSort(std::vector<int>& vec);

int main()
{
    std::vector<int> vec1{ 9,3,5,1,7,2,8,4 };

    insertionSort(vec1);

    // [ 1 2 3 4 5 7 8 9 ]
    std::cout << "[ ";
    for (int val : vec1)
    {
        std::cout << val << " ";
    }
    std::cout << "]" << std::endl;

    return 0;
}

void insertionSort(std::vector<int>& vec)
{
    int i, j;
    int currVal;

    for (i = 1; i < vec.size(); ++i)
    {
        currVal = vec[i];
        j = i - 1;

        while (j >= 0 && vec[j] > currVal)
        {
            vec[j + 1] = vec[j];
            --j;
        }

        vec[j + 1] = currVal;
    }
}
```
</TabsContent>
<TabsContent value="python">
```python 
def insertion_sort(list):
    for i in range(1, len(list)):
        currVal = arr[i]
        j = i - 1
        while j >= 0 and list[j] > currVal:
            list[j + 1] = list[j]
            j -= 1
        list[j + 1] = currVal
    return list


arr = [9, 3, 5, 1, 7, 2, 8, 4]
sorted_arr = insertion_sort((arr))

# [1, 2, 3, 4, 5, 7, 8, 9]
print(sorted_arr)
```
</TabsContent>
<TabsContent value="c">
```c 
// gcc insertion_sort.c -o insertion_sort && ./insertion_sort

#include <stdio.h>

void insertionSort(int array[], int size);
void printArray(int array[], int size);

int main()
{
    int arr[] = {9, 3, 5, 1, 7, 2, 8, 4};
    int size = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, size);

    // 1 2 3 4 5 7 8 9
    printArray(arr, size);

    return 0;
}

void insertionSort(int array[], int size)
{
    int i, j;
    int currVal;

    for (i = 1; i < size; ++i)
    {
        currVal = array[i];

        j = i - 1;
        while (j >= 0 && array[j] > currVal)
        {
            array[j + 1] = array[j];
            j--;
        }

        array[j + 1] = currVal;
    }
}

void printArray(int array[], int size)
{
    int i;

    for (i = 0; i < size; ++i)
    {
        printf("%d ", array[i]);
    }
    printf("\n");
}
```
</TabsContent>
<TabsContent value="ts">
```ts 
function insertionSort(array: number[]): number[] {
  for (let i = 1; i < array.length; i++) {
    const currVal = array[i];

    let j: number = i - 1;
    while (j >= 0 && array[j] > currVal) {
      array[j + 1] = array[j];
      j -= 1;
    }

    array[j + 1] = currVal;
  }
  return array;
}

const arr: number[] = [9, 3, 5, 1, 7, 2, 8, 4];
const sortedArr: number[] = insertionSort(arr);

// [1, 2, 3, 4, 5, 7, 8, 9]
console.log(sortedArr);
```
</TabsContent>
</Tabs>

Time Complexity:

- Best case: `O(n)`
- Average and Worst case: `(O(n^2))`

Space Complexity: O(1)

### Search Algorithms

#### Binary Search

Binary search is a divide and conquer algorithm used to efficiently search for a specific element in a sorted array. It works by repeatedly dividing the search space in half, eliminating the half that cannot contain the target element.

**Implementation**

`JavaScript`

```js
function binarySearch(array, target) {
  // lowest index of search space
  let low = 0;
  // highest index of search space
  let high = array.length - 1;

  while (low <= high) {
    // find the middle index
    let mid = Math.floor((low + high) / 2);

    if (array[mid] === target) {
      // target element found at middle index
      return mid;
    } else if (array[mid] < target) {
      // update lower bound to search in right half
      low = mid + 1;
    } else {
      // update upper bound to search in lower half
      high = mid - 1;
    }
  }

  // if we reach here, target was not found
  return -1;
}
```

Other implementations: [`Java`](https://github.com/mathewbushuru/algorithms/blob/main/algorithms/search-algorithms/binary-search/java/BinarySearch.java),[`C++`](https://github.com/mathewbushuru/algorithms/blob/main/algorithms/search-algorithms/binary-search/cpp/binarySearch.cpp), [`Python`](https://github.com/mathewbushuru/algorithms/blob/main/algorithms/search-algorithms/binary-search/python/binarySearch.py) ,[`C`](https://github.com/mathewbushuru/algorithms/blob/main/algorithms/search-algorithms/binary-search/c/binarySearch.c), [`TypeScript`](https://github.com/mathewbushuru/algorithms/blob/main/algorithms/search-algorithms/binary-search/typescript/binarySearch.ts)

Time complexity: `O(log(n))`

Space complexity: `O(1)`

We can also use recursion to implement binary search but it has a worse space complexity.

```js
function binarySearchRecursive(array, target) {
  return binarySearchRecursiveHelper(array, target, 0, array.length - 1);
}

function binarySearchRecursiveHelper(array, target, low, high) {
  if (low > high) {
    // target element not found
    return -1;
  }

  // find middle index
  let mid = Math.floor((low + high) / 2);

  if (array[mid] === target) {
    // target element found at middle index
    return mid;
  } else if (array[mid] < target) {
    // search in right half
    return binarySearchRecursiveHelper(array, target, mid + 1, high);
  } else {
    // search in left half
    return binarySearchRecursiveHelper(array, target, low, mid - 1);
  }
}

const arr = [1, 2, 3, 4, 5, 6, 7, 8];

// 5
console.log(binarySearchRecursive(arr, 6));
```

Time complexity: `O(log(n))`

Space complexity: `O(log(n))`. Each recursive call adds a new frame to the call stack containing the local variables and parameters of each function call. The depth of the recursive calls corresponds to the number of times the search space is halved until the base case is reached.

---

## Data Structures

### Arrays and Strings

I am putting arrays and strings together since their problems are often interchangeable.

**Array operations**

`JavaScript`

```js
/**
 * Declaration
 */
const arr = []; // empty array
const arrWithValues = [1, 2, 3, 4, 5]; // Array  with values
const arrWithSize = new Array(5); // Array with size

/**
 * Accessing elements
 */
let firstElement = arrWithValues[0]; // 1

/**
 * Setting elements
 */
arrWithValues[0] = 100;

/**
 * Array length
 */
const length = arrWithValues.length;

/**
 * Iterating over arrays
 */
for (let value of arrWithValues) {
  console.log(value);
}
for (let i = 0; i < arrWithValues.length; i++) {
  console.log(arrWithValues[i]);
}

/**
 * Multi-dimensional arrays
 */
const multiArray = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
];
console.log(multiArray[1][2]); // 6

/**
 * Common methods
 */
// add to end
arrWithValues.push(200);

// remove from end
arrWithValues.pop();

// add to beginning
arrWithValues.unshift(10);

// remove from beginning
let firstItem = arrWithValues.shift();

// slice array - creates new array object not including end
let start = 0;
let end = 3;
const newArr = arrWithValues.slice(start, end);

// splice array - add, remove or replace existing elements in place
const months = ["Jan", "Mar", "Apr", "Jun"];
let startIndex = 1;
let numOfElementsToRemove = 0;
months.splice(startIndex, numOfElementsToRemove, "Feb");
```

Other languages: [`Java - Arrays`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/arrays/java/ArrayOperations.java), [`Java - ArrayLists`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/arrays/java/ArrayListOperations.java), [`C++ - Arrays`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/arrays/cpp/arrayOperations.cpp), [`C++ - Vectors`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/arrays/cpp/vectorOperations.cpp)

**String operations**

`JavaScript`

```js
/**
 * declaration / initialization
 */
let str1 = "This is a string";
let str2 = 'This is also a string';
let str3 = `Template literal string, ${str1}`;

/**
 * accessing characters
 */
let char = str1[5];

/**
 * string length
 */
let len = str1.length;

/**
 * finding a substring
 */
// first occurrence (-1 if not found)
let position = str3.indexOf("string");      // 17

// last occurrence
let lastPosition = str3.lastIndexOf("string");    // 35

// checking substring existence
let exists = str1.includes("string");       // true

/**
 * substring, slice
 */
// substring(start, end);
// extract characters from start to (end - 1)
let sub = str1.substring(5, 11);              // 'is a s'

// slice(start, end);
// similar to substring but can accept negative indices
let sub2 = str1.slice(5, -1);                 // 'is a strin'

/**
 * string manipulation
 */
// concatenation
let concatedStr = str1 + " " + str2;
let concatedStr2 = str1.concat(str2);

// template literals
let name = "Matt";
let greeting = `Hello ${name}!`;

// changing case
let upper = str1.toUpperCase();
let lower = str1.toLowerCase();

// trimming spaces at start and end
let trimmed = "    extra spaces     ".trim();         // 'extra spaces'

/**
 * splitting and joining
 */
// split(delimiter); - string into an array
let words = str1.split(" ");

// join(delimiter); - array into string
let sentence = words.join(" ");

/**
 * replacing text
 */
let replaced = str1.replace("string", "replacedString");
```

JavaScript strings are immutable so methods that seem to modify strings like `replace` or `toUpperCase` actually return new strings.

Other languages: [`Java `](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/strings/java/StringOperations.java), [`C++ `](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/strings/cpp/stringOperations.cpp)

### Trees

A tree is a hierarchical data structure that represents a collection of elements called nodes. The nodes are connected by edges to form a tree-like structure. They enable efficient organization and retrieval of data.

The root is a special node that serves as the top-most node in a hierarchy. Each node in the tree, except for the root, has exactly one parent node and zero or more child nodes. Nodes directly connected to a particular node are called its children, and the node that connects to its children is called the parent.

#### Binary Trees

This is a tree in which each node has at most two children, referred to as the left child and the right child. Each child node is either a leaf node (having no children) or an internal node (having one or more children).

A complete binary tree is one in which each level of the tree is completely filled except the last level, and all nodes appear as far left as possible . A full/extended binary tree is one where no node has only one child - each node has either zero or two children. A perfect binary tree is both full and complete.

Binary tree traversal is the process of visiting each node in the tree exactly once. Three common methods of traversing binary trees are in-order traversal, pre-order traversal, and post-order traversal.

- In-order: Nodes are visited in the order 'left subtree' - 'parent node' - 'right subtree'. The left node is visited first, followed by the parent node, then the right child. This is used in binary search trees because it visits the nodes in ascending order if the tree is structured properly.
- Pre-order: Nodes are visited in the order 'parent node' - 'left subtree' - 'right subtree'. The parent node is visited before its children. It is useful for creating a copy of the tree, as the order of visiting the nodes allows for easy replication of the structure.
- Post-order: Nodes are visited in the order 'left subtree' - 'right subtree' - 'parent node'. The children are visited before the parent node. This is used in deleting nodes as it ensures the node is only deleted after its children have been deleted.

![binary-tree-traversal](https://raw.githubusercontent.com/mathewbushuru/algorithms/main/data-structures/imgs/binary-tree-traversal2.jpeg)

Note that trees can also be traversed in level-order (breadth-first algorithm.)

We can reconstruct a binary tree if given at least two traversal results. First traversal must be the in-order result, and the second can be either pre-order or post-order traversal. The in-order traversal helps us identify left and right child nodes, and the pre/post-order determines the root node. First element in pre-order traversal is the root node, while the last in post-order is the root node.

For example, if we are given two arrays with the preorder and inorder traversal results, we use the preorder array to find the root node (first element in array). We then locate the index of this root node in the inorder traversal array. Elements to the left of the root in the inorder array are from the left subtree. Similarly, those to the right of the root node form the right subtree. We recursively select elements from the preorder array and create its left and right subtrees from the inorder array.

![binary-tree-reconstruction](https://raw.githubusercontent.com/mathewbushuru/algorithms/main/data-structures/imgs/binary-tree-reconstruction4.jpeg)

**Implementation**

`JavaScript`

```js
class Node {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }
}

class BinaryTree {
  constructor() {
    this.root = null;
  }

  insert(value) {
    const newNode = new Node(value);

    if (this.root === null) {
      this.root = newNode;
    } else {
      this.insertNode(this.root, newNode);
    }
  }

  insertNode(node, newNode) {
    if (newNode.value < node.value) {
      // if tree required to be a binary search tree, then smaller values to left subtree
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      // newNode is larger, insert in right subtree
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }

  delete(value) {
    this.root = this.deleteNode(this.root, value);
  }

  deleteNode(node, value) {
    if (node === null) {
      return null;
    }

    if (value < node.value) {
      node.left = this.deleteNode(node.left, value);
    } else if (value > node.value) {
      node.right = this.deleteNode(node.right, value);
    } else {
      // delete current node
      if (node.left === null && node.right === null) {
        // has no children
        node = null;
      } else if (node.left === null) {
        //has one right child
        node = node.right;
      } else if (node.right === null) {
        // has one left child
        node = node.left;
      } else {
        // has two children
        const minRight = this.findMinNode(node.right);
        // minRight is larger than all left subtree values
        // and ofc smaller than all right subtree values
        // alternative would be to use max value in left subtree
        node.value = minRight.value;
        node.right = this.deleteNode(node.right, minRight.value);
      }
    }
    return node;
  }

  findMinNode(node) {
    if (node.left === null) {
      // nothing in left subtree, so parent is automatically the min
      return node;
    } else {
      return this.findMinNode(node.left);
    }
  }

  inOrderTraversal(callbackFn) {
    this.inOrderTraversalNode(this.root, callbackFn);
  }

  inOrderTraversalNode(node, callbackFn) {
    if (node !== null) {
      this.inOrderTraversalNode(node.left, callbackFn);
      callbackFn(node.value);
      this.inOrderTraversalNode(node.right, callbackFn);
    }
  }

  preOrderTraversal(callbackFn) {
    this.preOrderTraversalNode(this.root, callbackFn);
  }

  preOrderTraversalNode(node, callbackFn) {
    if (node !== null) {
      callbackFn(node.value);
      this.preOrderTraversalNode(node.left, callbackFn);
      this.preOrderTraversalNode(node.right, callbackFn);
    }
  }

  postOrderTraversal(callbackFn) {
    this.postOrderTraversalNode(this.root, callbackFn);
  }

  postOrderTraversalNode(node, callbackFn) {
    if (node !== null) {
      this.postOrderTraversalNode(node.left, callbackFn);
      this.postOrderTraversalNode(node.right, callbackFn);
      callbackFn(node.value);
    }
  }
}
```

An example binary tree (BST) is shown below

![binary-tree-traversal2](https://raw.githubusercontent.com/mathewbushuru/algorithms/main/data-structures/imgs/binary-tree-traversal2.jpeg)

```js
const binaryTree = new BinaryTree();

binaryTree.insert(8);
binaryTree.insert(3);
binaryTree.insert(10);
binaryTree.insert(1);
binaryTree.insert(6);
binaryTree.insert(14);
binaryTree.insert(4);
binaryTree.insert(7);
binaryTree.insert(13);

console.log("In order traversal");
// 1 3 4 6 7 8 10 13 14
binaryTree.inOrderTraversal((value) => console.log(value));
console.log("---");

console.log("Pre order traversal");
// 8 3 1 6 4 7 10 14 13
binaryTree.preOrderTraversal((value) => console.log(value));
console.log("---");

console.log("Post order traversal");
// 1 4 7 6 3 13 14 10 8
binaryTree.postOrderTraversal((value) => console.log(value));
console.log("---");

binaryTree.delete(6);

console.log("In order traversal after deleting 6");
// 1 3 4 7 8 10 13 14
binaryTree.inOrderTraversal((value) => console.log(value));
console.log("---");
```

Other implementations: [`C++`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/cpp/binaryTree.cpp), [`Java`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/java/BinaryTreeTestdrive.java) ,[`TypeScript`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/typescript/binaryTree.ts), [`C`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/c/binaryTree.c), [`Python`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/python/binaryTree.py), [`C#`](https://github.com/mathewbushuru/algorithms/blob/main/data-structures/binary-tree/csharp/BinaryTree.cs)

The complexities of this implementation are:

1. Node insertion

- The average and worst time complexity of inserting a node in a binary tree in `O(log(n))` for balanced trees and `O(n)` for skewed trees. Each insertion in a balanced binary tree reduces search space by half, while it may require traversing through all the nodes in a skewed tree.
- The space complexity is `O(1)` as we are not using any data structures that grow the size of the tree.

2. Node deletion

- The average and worst time complexity if `O(log(n))` for balanced trees and `O(n)` for skewed trees.

3. Traversal operations

- In-order, pre-order and post-order traversals visit each node in the binary tree once.
- The time complexity is `O(n)` where n is the number of nodes in the tree.
- The space complexity is `O(h)` where h is the height of the tree. The recursive calls for traversing the tree occupies space in the call stack, and the maximum depth of the recursive call corresponds to the height of the tree. For a skewed tree, the space complexity degrades to `O(n)`

#### Binary Search Trees

This is a binary tree with a special property: For every node, the value of each node in its left subtree is less than its value, and the value of each node in is right subtree is greater than its value.
